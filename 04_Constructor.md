## Constructors

Constructors are special methods that are automatically called whenever an object of a class are created. The constructor in C++ has the same name as the class or structure.


### Default Constructor

- A default constructor is automatically generated by the compiler if the programmer doesn't define one.

- This constructor doesn't take any argument as it is parameter less and initializes object members using default values.

- The default constructor is not generated by the compiler if the programmer has explicitly defined a constructor.

```c++
// Class with no explicity defined constructors
class A {
public:
};

int main() {
  
    A a;
    return 0;
}
```

In the above program the class A does not contains any explicitly defined constructor. Hence, The object of the class A is created without any parameters, As the class will use the default constructor generated by the compiler.


### Parameterized Constructor

- It allows to pass arguments to the constructors to initialize the data members.

- If a parameterized constructor is defined, the non-parameterized constructor should also be defined as compiler does not create the default constructor.

```c++
class A{
public:
    int val;
  
    A(int x) {
        val = x;
    }
};

int main() {
  
    A a(10);
    cout << a.val;
    return 0;
}
```

### Copy Constructor

- A copy constructor is a member function that initializes an object using another object of the same class. 

- It takes a reference to an object of the same class as an argument.

```c++
class A{
    public:
        int val;
        
        A(int x){ //parameterized constructor
            val = x;
        }
        
        A(A& a) { //copy constructor 
            val = a.val;
        }
};

int main() {
    A a1(20);
    
    A a2(a1);
    
    cout<<a2.val; //20
}
```

### Deep vs Shallow copy

- A shallow copy creates a new object and then inserts references to the original object's elements. This means that if the original object contains other objects, the copy will contain references to those same objects. As a result, changing a mutable element (like a list or dictionary) within the copied object will also change the original.

-  In contrast, a deep copy creates a completely new, independent object. It recursively copies all elements, including any nested objects. Therefore, the deep copy and the original object do not share any references, and changes made to the deep copy will not affect the original.

Note : A shallow copy is "shallow" because it only goes one level deep. It copies the container itself but doesn't recursively copy the objects inside.

For a vector<int>, the elements are the integers themselves. Since integers are primitive types, their values are copied directly. The shallow copy successfully duplicates the entire data.

For a vector<string>, the elements are std::string objects. A std::string is a complex object that internally holds a pointer to the actual characters on the heap. A shallow copy of the vector will create a new vector and copy these pointers, not the characters they point to.

This is why modifying a character within a string in the new vector changes the original: both vectors are pointing to the exact same sequence of characters in memory.

```c++
#include<bits/stdc++.h>
using namespace std;

class Car {
    public:
    string name;
    vector<string> colors;
    
    Car (string name, vector<string> colors)
    {
        this->name = name;
        this->colors = colors;
    }
};

int main()
{
  vector<string> bmw_colors = {"White", "Blue"};
  Car bmw("Honda", bmw_colors);
  
  Car deep_copy = bmw;
  deep_copy.colors.push_back("Black");
  cout<<"Deepcopy: ";
  for(string str: deep_copy.colors)
    cout<<str<<" ";
    
  cout<<endl<<"Original: ";
  for(string str: bmw.colors)
    cout<<str<<" ";
    
   Car* shallow_copy = &bmw;
   shallow_copy->colors.push_back("Black");
   cout<<endl<<"Shallow Copy: ";
   for(string str: shallow_copy->colors)
        cout<<str<<" ";
   cout<<endl<<"Original: ";
   for(string str: bmw.colors)
        cout<<str<<" ";
}
```

```Output
Deepcopy: White Blue Black 
Original: White Blue 

Shallow Copy: White Blue Black 
Original: White Blue Black 
```

### Difference btw assignment operator and copy constructor

- Copy constructor is called when a new object is created from an existing object, as a copy of the existing object. It creates a separate memory block for the new object. It is an overloaded constructor.

```
MyClass obj2(obj1);
```

- Assignment operator is called when an already initialized object is assigned a new value from another existing object. It does not automatically create a separate memory block or new memory space. However, if the class involves dynamic memory management, the assignment operator must first release the existing memory on the left-hand side and then allocate new memory as needed to copy the data from the right-hand side. It is a bitwise operator. 

```
MyClass obj1;
MyClass obj2;
obj2 = obj1;
```


### Move Constructor

Move constructor is like a copy constructor that constructs the object from the already existing objects., but instead of copying the object in the new memory, it makes use of move semantics to transfer the ownership of the already created object to the new object without creating extra copies. It can be seen as stealing the resources from other objects.


### Characteristics of Constructors

- The name of the constructor is the same as its class name.
- Constructors are mostly declared as public member of the class though they can be declared as private.
- Constructors do not return values, hence they do not have a return type.
- A constructor gets called automatically when we create the object of the class.

### Constructor overloading

Constructor overloading is a form of function overloading, where the compiler distinguishes between different constructors based on the number, type, or order of their parameters. When you create a new object, the compiler looks at the arguments you provide and calls the constructor that best matches the signature.

``` c++
class Area{
    public:
        double length, breadth, height;
        Area() {
            length=0.0;
            breadth=0.0;
            height=0.0;
        }
        Area(double side)
        {
            length=side;
            breadth=side;
            height=side;
        }
        Area(double l, double b, double h)
        {
            length = l;
            breadth = b;
            height = h;
        }
        double findArea()
        {
            return length*breadth*height;
        }
};

int main()
{
    double l, w, h;
    Area cube(5.2);
    cout<<"Area is "<<cube.findArea();
    Area cuboid(3.2, 5.4, 6.7);
    cout<<endl<<"Area is "<<cuboid.findArea();
}
```

```Output
Area is 140.608
Area is 115.776
```